/*
Абстрактный класс может содержать как абстрактные так и обычные методы, причем
причем класс котрый наследуется от абстрактного обязан реализовать логику абстрактных методов

интерейс - описывает методы и принимаемые им аргументы + может описывать типы данных как принмаемых аргументов так
и возвращаемых данных методом

класс может имплементировать несколько интерфейсов
 */

class User {
  userName: string;
  age: number;
}

/*
Данный Repository интерфейс универсален, его может юзать любой класс которому необходима реализация CRUD
и мы не можем захардкодить в качестве аргументов методов что попало.
здесь на помощь приходит дженерик <T> для обобщения
в данном случае тип Т это нечто общее что приходит откуда то из вне
 */

interface Repository<T> {
  create: (obj: T) => T;
  get: () => T;
  delete: (obj: T) => T;
  update: (obj: T) => T;
}

//Здесь как дженерик мы указываем класс который подставится вместо Т
class UserRepo implements Repository<User> {
  create(obj: User): User {
    return undefined
  }

  delete(obj: User): User {
    return undefined
  }

  get(): User {
    return undefined
  }

  update(obj: User): User {
    return undefined
  }

}